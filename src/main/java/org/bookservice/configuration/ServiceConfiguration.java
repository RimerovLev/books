package org.bookservice.configuration;

import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


@Configuration
public class ServiceConfiguration {

    // Создание бина ModelMapper
    @Bean
    public ModelMapper modelMapper() {
        // Создаем экземпляр ModelMapper
        ModelMapper modelMapper = new ModelMapper();

        // Настройка конфигурации ModelMapper
        modelMapper.getConfiguration()
                // Включаем соответствие полей по имени, что позволяет игнорировать различия в именах полей между объектами
                .setFieldMatchingEnabled(true)
                // Устанавливаем уровень доступа для полей объектов, чтобы ModelMapper мог использовать приватные поля
                .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE)
                // Устанавливаем стратегию сопоставления, строго проверяя совпадения имен и типов полей
                .setMatchingStrategy(MatchingStrategies.STRICT);

        // Возвращаем настроенный экземпляр ModelMapper
        return modelMapper;
    };
}


//Подробное объяснение и комментарии:
//        1. @Configuration:
//Эта аннотация говорит Spring, что класс содержит конфигурационные настройки для контекста приложения.
//Аннотированный класс будет обработан Spring контейнером, и его методы с аннотацией @Bean будут зарегистрированы
// как компоненты (или бины) в Spring контексте.
//
//        2. Метод modelMapper():
//Этот метод создает и конфигурирует объект ModelMapper, который используется для преобразования (маппинга) данных
// между различными объектами, например, между DTO и сущностями. Этот метод помечен аннотацией @Bean, что означает,
// что возвращаемый объект будет управляться Spring контейнером и доступен для внедрения (dependency injection).
//
//        3. Создание экземпляра ModelMapper:
//ModelMapper modelMapper = new ModelMapper(); — создается новый объект ModelMapper. Это центральный класс, который
// будет использоваться для преобразования объектов.
//
//        4. Настройки конфигурации ModelMapper:
//        .getConfiguration() — получает текущую конфигурацию для настройки маппера.
//
//setFieldMatchingEnabled(true):
//
//Включает возможность сопоставления полей, даже если имена этих полей не совпадают в разных объектах.
//        Например, если в исходном объекте есть поле first_name, а в целевом — firstName, то маппер будет пытаться
//        найти соответствие между этими полями, что важно для маппинга между различными структурами данных.
//setFieldAccessLevel(AccessLevel.PRIVATE):
//
//Этот параметр позволяет ModelMapper использовать приватные поля в объектах для маппинга. Обычно маппинг происходит
// через публичные геттеры/сеттеры, но с этой настройкой маппер сможет работать и с приватными полями. Это полезно,
// если ваши модели используют инкапсуляцию и имеют приватные поля.
//setMatchingStrategy(MatchingStrategies.STRICT):
//
//Устанавливает стратегию строгости при сопоставлении полей.
//MatchingStrategies.STRICT — маппер будет строго проверять, что поля с одинаковыми именами и типами точно совпадают.
//Важно: этот режим требует, чтобы и типы полей совпадали (например, строка с строкой, число с числом). Если типы не
// совпадают, будет выброшено исключение.
//
//        5. Возвращаем конфигурированный ModelMapper:
//Возвращаем настроенный экземпляр ModelMapper, который Spring контейнер будет использовать для внедрения в другие
// компоненты вашего приложения.
//6. @Bean:
//Аннотация @Bean говорит Spring, что метод создает компонент, который должен быть добавлен в контекст приложения как
// бин. Spring будет управлять этим объектом и внедрять его туда, где это необходимо.
//Важные моменты:
//ModelMapper — это библиотека, которая значительно упрощает процесс маппинга между объектами, особенно когда нужно
// преобразовывать данные между слоями приложения (например, из DTO в сущности и наоборот).
//Конфигурация, которую вы настроили, позволяет автоматически маппировать поля с одинаковыми именами, даже если они
// приватные в моделях, и делает процесс маппинга более строгим.